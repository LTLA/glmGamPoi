// #include <Rcpp.h>
#include <RcppArmadillo.h>

using namespace Rcpp;

// [[Rcpp::depends(RcppArmadillo)]]

// [[Rcpp::export]]
IntegerVector makeCumSumLookupVector(IntegerVector y){
  double max_y = max(y);
  IntegerVector lookupTable(max_y+1);
  IntegerVector cumsumLookupTable(max_y);
  for(int i = 0; i < y.size(); i++){
    lookupTable[y[i]]++;
  }
  int lastelem = 0;
  for(int  i = lookupTable.size()-1; i >= 1; i--){
    cumsumLookupTable[i-1] = lookupTable[i] + lastelem;
    lastelem = cumsumLookupTable[i-1];
  }
  return cumsumLookupTable;
}

/**
 * The score_function_bandara_fast() is defined in terms of r=1/theta, because
 * it implements the result if the derivative of log(likelihood) wrt to r is taken
 *
 * the cumsumLookupTable can be quickly generated by calling makeCumSumLookupVector(y).
 */

// [[Rcpp::export]]
double score_function_bandara_fast(IntegerVector y, IntegerVector cumsumLookupTable, NumericVector mu,
                                   double r, const arma::mat& model_matrix, bool do_cr_adj){
  double cr_term = 0.0;
  if(do_cr_adj){
    arma::vec w_diag = 1.0/(1.0/mu + 1/r);
    arma::vec dw_diag = pow(mu / (mu + r), 2);
    arma::mat b = model_matrix.t() * (model_matrix.each_col() % w_diag);
    arma::mat db = model_matrix.t() * (model_matrix.each_col() % dw_diag);
    cr_term = -0.5 * trace(b.i() * db);
  }

  double digammaSummand = 0.0;
  for(int v = 0; v < cumsumLookupTable.size(); v++){
    digammaSummand += cumsumLookupTable[v] / (r + v + 1 - 1);
  }

  double otherSummand = 0.0;
  for(int i = 0; i < y.size(); ++i){
    otherSummand += log(1 + mu[i] / r) + (y[i] - mu[i]) / (mu[i] + r);
  }
  return digammaSummand - otherSummand + cr_term;
}


// [[Rcpp::export]]
double score_deriv_function_bandara_fast(IntegerVector y, IntegerVector cumsumLookupTable,NumericVector mu,
                                         double r, const arma::mat& model_matrix, bool do_cr_adj){
  double cr_term = 0.0;
  if(do_cr_adj){
    arma::vec w_diag = 1/(1/mu + 1/r);
    arma::vec dw_diag = pow(mu / (mu + r), 2);
    arma::vec d2w_diag = -2 * pow(mu, 2) / pow(mu + r, 3);

    arma::mat b = model_matrix.t() * (model_matrix.each_col() % w_diag);
    arma::mat db = model_matrix.t() * (model_matrix.each_col() % dw_diag);
    arma::mat d2b = model_matrix.t() * (model_matrix.each_col() % d2w_diag);
    arma::mat b_i = b.i();
    double ddetb = ( det(b) * trace(b.i() * db) );
    double d2detb = ( det(b) * (pow(trace(b_i * db), 2) - trace(b_i * db * b_i * db) + trace(b_i * d2b)) );
    cr_term = 0.5 * pow(ddetb/det(b), 2) - 0.5 * d2detb / det(b);
  }

  double digammaSummand = 0.0;
  for(int v = 0; v < cumsumLookupTable.size(); v++){
    digammaSummand += cumsumLookupTable[v] / pow(r + v + 1 - 1, 2);
  }
  double otherSummand = 0.0;
  for(int i = 0; i < y.size(); ++i){
    otherSummand += mu[i] / (mu[i] * r + pow(r, 2)) + (y[i] - mu[i]) / pow(mu[i] + r, 2);
  }

  return -digammaSummand + otherSummand + cr_term;
}


//--------------------------------------------------------------------------------------------------//
// The following code was originally copied from https://github.com/mikelove/DESeq2/blob/master/src/DESeq2.cpp
// I adapted it to the needs of this project by:
//  * renaming alpha -> theta for consitency
//  * removing the part for the prior on theta
//  * renaming x -> model_matrix
//  * additional small changes



/*
 * DESeq2 C++ functions
 *
 * Author: Michael I. Love, Constantin Ahlmann-Eltze
 * Last modified: January 17, 2020
 * License: LGPL (>= 3)
 *
 * Note: The canonical, up-to-date DESeq2.cpp lives in
 * the DESeq2 library, the development branch of which
 * can be viewed here:
 *
 * https://github.com/mikelove/DESeq2/blob/master/src/DESeq2.cpp
 */


// this function returns the log posterior of dispersion parameter alpha, for negative binomial variables
// given the counts y, the expected means mu, the design matrix x (used for calculating the Cox-Reid adjustment),
// and the parameters for the normal prior on log alpha

// [[Rcpp::export]]
double conventional_loglikelihood_fast(NumericVector y, NumericVector mu, double log_theta, const arma::mat& model_matrix, bool do_cr_adj) {
  double theta = exp(log_theta);
  double cr_term = 0.0;
  if(do_cr_adj){
    arma::vec w_diag = pow(pow(mu, -1) + theta, -1);
    arma::mat b = model_matrix.t() * (model_matrix.each_col() % w_diag);
    cr_term = -0.5 * log(det(b));
  }
  double theta_neg1 = R_pow_di(theta, -1);
  double ll_part = sum(lgamma(y + theta_neg1) - lgamma(theta_neg1) - y * log(mu + theta_neg1) - theta_neg1 * log(1.0 + mu * theta));
  return  ll_part + cr_term;
}

// this function returns the derivative of the log posterior with respect to the log of the
// dispersion parameter alpha, given the same inputs as the previous function

// [[Rcpp::export]]
double conventional_score_function_fast(NumericVector y, NumericVector mu, double log_theta, const arma::mat& model_matrix, bool do_cr_adj) {
  double theta = exp(log_theta);
  double cr_term = 0.0;
  if(do_cr_adj){
    arma::vec w_diag = pow(pow(mu, -1) + theta, -1);
    arma::vec dw_diag = -1.0 * pow(pow(mu, -1) + theta, -2);
    arma::mat b = model_matrix.t() * (model_matrix.each_col() % w_diag);
    arma::mat db = model_matrix.t() * (model_matrix.each_col() % dw_diag);
    double ddetb = ( det(b) * trace(b.i() * db) );
    cr_term = -0.5 * ddetb / det(b);
  }
  double theta_neg1 = R_pow_di(theta, -1);
  double theta_neg2 = R_pow_di(theta, -2);
  double ll_part = theta_neg2 * sum(Rf_digamma(theta_neg1) + log(1 + mu*theta) - mu*theta*pow(1.0 + mu*theta, -1) - digamma(y + theta_neg1) + y * pow(mu + theta_neg1, -1));
  // Note: return dlog_post/dalpha * alpha because we take derivatives w.r.t log alpha
  return (ll_part + cr_term) * theta;
}

// this function returns the second derivative of the log posterior with respect to the log of the
// dispersion parameter alpha, given the same inputs as the previous function

// [[Rcpp::export]]
double conventional_deriv_score_function_fast(NumericVector y, NumericVector mu, double log_theta, const arma::mat& model_matrix, bool do_cr_adj) {
  double theta = exp(log_theta);
  double cr_term = 0.0;
  if(do_cr_adj){
    arma::vec w_diag = pow(pow(mu, -1) + theta, -1);
    // arma::mat w = arma::diagmat(as<arma::vec>(w_diag));
    arma::vec dw_diag = -1 * pow(pow(mu, -1) + theta, -2);
    // arma::mat dw = arma::diagmat(as<arma::vec>(dw_diag));
    arma::vec d2w_diag = 2 * pow(pow(mu, -1) + theta, -3);
    // arma::mat d2w = arma::diagmat(as<arma::vec>(d2w_diag));
    arma::mat b = model_matrix.t() * (model_matrix.each_col() % w_diag);
    arma::mat b_i = b.i();
    arma::mat db = model_matrix.t() * (model_matrix.each_col() % dw_diag);
    arma::mat d2b = model_matrix.t() * (model_matrix.each_col() % d2w_diag);
    double ddetb = ( det(b) * trace(b.i() * db) );
    double d2detb = ( det(b) * (R_pow_di(trace(b_i * db), 2) - trace(b_i * db * b_i * db) + trace(b_i * d2b)) );
    cr_term = 0.5 * R_pow_di(ddetb/det(b), 2) - 0.5 * d2detb / det(b);
  }
  double theta_neg1 = R_pow_di(theta, -1);
  double theta_neg2 = R_pow_di(theta, -2);
  double ll_part = -2 * R_pow_di(theta, -3) * sum(Rf_digamma(theta_neg1) + log(1 + mu*theta) - mu*theta*pow(1 + mu*theta, -1) -
                                                  digamma(y + theta_neg1) + y * pow(mu + theta_neg1, -1)) +
    theta_neg2 * sum(-1 * theta_neg2 * Rf_trigamma(theta_neg1) + pow(mu, 2) * theta * pow(1 + mu*theta, -2) +
                     theta_neg2 * trigamma(y + theta_neg1) + theta_neg2 * y * pow(mu + theta_neg1, -2));

  // Note: return (d2log_post/dalpha2 * alpha^2 + dlog_post/dalpha * alpha)
  //            = (d2log_post/dalpha2 * alpha^2 + dlog_post/dlogalpha)
  // because we take derivatives w.r.t log alpha
  double res = ((ll_part + cr_term) * R_pow_di(theta, 2) + conventional_score_function_fast(y, mu, log_theta, model_matrix, do_cr_adj));
  return(res);
}


